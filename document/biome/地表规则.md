## 地表规则
### 地表规则

---

1. 地表规则的四种类型：bandlands（恶地）、block（方块）、condition（条件）和sequence（序列）
2. 恶地（Bandlands）：用于恶地生态群系
3. 方块（Block）：用于放置方块
4. 条件（condition）：用于判断条件然后执行另一个地表规则
5. 序列（sequence）：用于按照顺序执行一系列地表规则

### 表层厚度

---

1. 地表规则中的一个量称为表层厚度。表层厚度并不是直接表示地表规则的影响范围，或者是表面的总厚度。通常情况下，地表规则会配合表层高度，来决定表面的总厚度。表层厚度由噪声minecraft:surface决定，将（X,0,Z）处的噪声值 × 2.75 + 3.0作为表层厚度的值
2. 例如：（生成地表为泥土的地表规则）[简单的地表规则的例子](https://www.bilibili.com/read/cv33691594)
```java
public class MaterialRule() {
    private static final MaterialRules.MaterialRule DIRT = MaterialRules.block(Blocks.DIRT.getDefaultState());
}
```
- Stone Depth的地表规则
  * Stone Depth的地表规则条件，用来限制地表规则作用的深度
  * 方法函数``stoneDepth(int offset, boolean addSurfaceDepth, int secondaryDepthRange, VerticalSurfaceType verticalSurfaceType)``
  * 其中offset控制深度为2+1=3格，而then_run则是如果条件满足，也就是深度在三格以内的时候，要执行的地表规则，在这里是放置泥土**添加土层**
```java
public class MaterialRule() { 
    public static void rule() {
        MaterialRules.MaterialRule dirt = MaterialRules.block(Blocks.DIRT.getDefaultState());
        MaterialRules.MaterialRule surface = MaterialRules.condition(MaterialRules.stoneDepth(2, false, 0, VerticalSurfaceType.FLOOR), dirt);
    }
}
```
  * 但是效果是，表面光秃秃的泥土，无生机感，于是在深度为1以内的时候，放置草方块，此后，在深度为3以内但是不在1以内的时候，放置泥土
- Sequence的地表规则
  * 对于这个列表的若干规则AB，如果前面的一个规则A对于某方块坐标测试成功，并替换成了其他方块，那么即使后面的规则B对于规则A处理过的方块位置同样测试成功，但是因为A已经处理过该坐标，因此B在这里执行失败。表现为只执行了A，没有执行B。(**wplxfore的经验总结和评论**)
  * **添加草皮**
```java
public class MaterialRule {

    public static void rule() {
        MaterialRules.MaterialRule dirt = MaterialRules.block(Blocks.DIRT.getDefaultState());
        MaterialRules.MaterialRule grass = MaterialRules.block(Blocks.GRASS_BLOCK.getDefaultState());
        MaterialRules.MaterialRule grassSurface = MaterialRules.condition(MaterialRules.stoneDepth(0, false, 0, VerticalSurfaceType.FLOOR), grass);
        MaterialRules.MaterialRule dirtSurface = MaterialRules.condition(MaterialRules.stoneDepth(2, false, 0, VerticalSurfaceType.FLOOR), dirt);

        MaterialRules.MaterialRule list = MaterialRules.sequence(grassSurface, dirtSurface);
    }
}
```
- Biome
  * 用于控制地表规则可以应用的生物群系，biome_is就是可以应用的生物群系的列表
  * ``biome(RegistryKey\<Biome\>... biomes)``：添加一个或多个生态群系
  * ``biome(List<RegistryKey\<Biome>> biomes)``：添加一个生态群系列表
- Noise Threshold
  * 检测的方块的坐标的坐标是(x, y, z)，则检测(x, 0 ,z)处指定噪声的值，并判断它是否在指定的闭区间内
  * 函数方法：``noiseThreshold(RegistryKey<DoublePerlinNoiseSampler.NoiseParameters> noise, double min, double max)``
- Vertical Gradient
  * 提供y1和y2的坐标，而且y1和y2的坐标都是垂直锚点的形式，将在两个坐标间进行过渡渐变处理。在过度位置上随机放置两种方块用于渐变。
  * 函数方法：``verticalGradient(String id, YOffset trueAtAndBelow, YOffset falseAtAndAbove)``
  * trueAtAndBelow：y坐标 < true_at_and_below 时，这个条件会永远通过
  * falseAtAndAbove：y坐标 > false_at_and_above 时，这个条件会永远不通过，而在期间可以随机渡过通过
  * 例子：将上界设置为了60，下界设置为54，则60以上条件永远不通过，作为石头；54以下条件永远通过，作为为泥土。在它们之间，泥土和石头进行了平滑的过渡。
  * 其中：absolute指定了一个y坐标的绝对值，在主世界中y取值区间为\[-64, 320]
```java
public class MaterialRule { 
    public static void rule() {
        MaterialRules.MaterialRule dirt = MaterialRules.block(Blocks.DIRT.getDefaultState());
        MaterialRules.MaterialCondition transition = MaterialRules.verticalGradient("deepslate", YOffset.fixed(54), YOffset.fixed(60));
        
        MaterialRules.MaterialRule result = MaterialRules.condition(transition, dirt);
  }
}
```
  * 原版深板岩和石头过度地带的实现原理
```java
public class MaterialRule { 
    public static void rule() {
        MaterialRules.MaterialRule deepslate = MaterialRules.block(Blocks.DEEPSLATE.getDefaultState());
        
        MaterialRules.MaterialCondition transition = MaterialRules.verticalGradient("deepslate", YOffset.fixed(54), YOffset.fixed(60));
        MaterialRules.MaterialRule result = MaterialRules.condition(transition, deepslate);
  }
}
```
- Above Bottom
  * Above Bottom 指定从世界底部开始计算的相对高度。注意这里的世界底部不是地形的底部，而是世界高度限制的底部。
  * 例如在主世界上，``YOffset.aboveBottom(54)``，由于高度限制，输入54，实际上是-64+54=-10，对应的y轴坐标就是-10
- Below Top
  * Below Top 指定从世界顶部开始计算的相对高度，注意这里的世界顶部不是地形的顶部，而是世界高度限制的顶部
  * 例如在主世界上，``YOffset.belowTop(54)``，由于高度限制，输入54，实际上是320-54=266，对应的Y坐标就是266
  * 区别：true_at_and_below（得到的y轴上限）是较大的一个，true_at_and_below（得到的y轴坐标）是较小的那一个
- Y Above
  * Y Above：检查方块是否位于指定的Y坐标上方。例如方块坐标为Y=0的方块被认为位于Y=0的上方
  * 区别：vertical_gradient有些类似，但是它没有两个坐标之间的过渡地带，只有一个坐标，大于这个坐标则条件成立，小于这个坐标则条件失败，与vertical_gradient相反
  * 使用方法：``MaterialRules.aboveY(YOffset.fixed(50), 2)``
    + 当中解释
    + anchor：最小Y坐标，意味着要y < 60的方块对此条件通过，则y >= 60 的上方固体方块的数量必然需要大于它与y=60之间的距离，也就是说，它和y=60之间，不可能能存在空气方块。如果当小洞穴中的有洞穴空气方块的存在时，则不会被替换为泥土
    + runDepthMultiplier（surface_depth_multiplier）：取值为-20到20的闭区间。表示受表层厚度的影响程度，条件成功的最小Y坐标会在anchor值的基础上加上表层厚度 × surface_depth_multiplier格
    + Add Stone Depth：默认为false
- Water
  * 通常用于水下地形的生成，用于检测当前位置距离上方最高液体方块表面的距离是否小于指定的值。注意这里由于offset为负数，因此距离应该是wiki中描述的”相对于上方液面的高度“的绝对值
  * 使用方法：``MaterialRules.water(-1, 0);``
- Temperature
  * 检查此处的随高度调整的温度是否足够低以可以下雪
  * 使用方法：``MaterialRules.temperature();``
- Steep
  * 检查此处是否为背阳（朝向北或朝东）且高度差大于4格的陡峭斜坡
  * 使用方法：``MaterialRules.steepSlope();``
- Not
  * not用于条件取反，invert（target）中的参数表示要取反的条件，即invert中的条件不通过，这个not条件才会通过
  * 函数方法：``not(MaterialRules.MaterialCondition target)``
- Hole
  * 检查表层厚度是否小于0
  * 使用方法：``MaterialRules.hole()``
- Above Preliminary Surface
  * 是否高于预处理地表，预处理地表高度为由initial_density_without_jaggedness产生的地表高度插值后，向下偏移8格，再加上表层厚度后的值
  * 使用方法：``MaterialRules.surface();``
- Stone Depth
  * 检测当前位置和上方表面是否小于等于指定的距离
  * 相似：具体的参数和water和y_above较为类似
  * 函数方法：``stoneDepth(int offset, boolean addSurfaceDepth, int secondaryDepthRange, VerticalSurfaceType verticalSurfaceType)``

### 参考：[Wiki噪声设置](https://zh.minecraft.wiki/w/噪声设置)和[地表规则](https://www.bilibili.com/read/cv33691594)